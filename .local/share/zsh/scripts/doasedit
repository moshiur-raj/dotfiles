#! /usr/bin/zsh

# check dependencies
command -v doas echo ls grep awk date md5sum rm stat cat install chgrp dirname basename exit > /dev/null || {
	echo dependencies not satisfied; exit 1
}

# check if env vars are set properly
[[ $USERNAME != "root" ]] && {
	echo please run with root priviledges; exit 1
}
[[ $NONROOTUSER == "root" ]] && {
	echo please run doasedit from a non root user; exit 1
}
[[ -z $NONROOTUSER ]] || [[ -z $EDITOR ]] && {
	echo please set env vars properly; exit 1
}
# if number of arguments is zero then exit
[[ $# -eq 0 ]] && {
	echo No arguments; exit 1
}
# do not allow process substitution in arguments
[[ $@ =~ ".*/proc/self/fd/.+" ]] && {
	echo please do not use process substitution in arguments; exit 1
}

# directory for storing temporary files
doaseditdir="/tmp/doasedit"
# if the directory exists then check for permissions. otherwise create the directory
# the directory should be owned by root and the group should be NONROOTUSER.
# NONROOTUSER can only execute the directory and others can do nothing
doaseditdit_permission="drwx--x---root$NONROOTUSER"
if [[ -d $doaseditdir ]]; then
	[[ $(ls -l $(dirname $doaseditdir) | grep $(basename $doaseditdir) |
		awk '{ print $1 $3 $4 }') != $doaseditdit_permission ]] && {
	echo improper permissions for $doaseditdir; exit 1
	}
else
	{ mkdir -m 710 $doaseditdir &&
	chgrp $NONROOTUSER $doaseditdir } ||
	{ echo failed to create directory; exit 1 }
fi

# declaring some arrays
declare -a file temp_file mod_time1 mod_time2
# clear files and exit
clear_and_exit () {
[[ -z $(printf %s ${temp_file[@]}) ]] && rm ${temp_file[@]}; exit 1
}

for i in $(seq 1 $#)
do
	arg="${@[i]}"
	# if absolute path is given use that otherwise expand the location
	if [[ $arg[1] == "/" ]]; then
		file[i]="$arg"
	else
		file[i]="$PWD/$arg"
	fi
	directory="$(dirname ${file[i]})"


	# if the file can be edited without root priviledges then exit
	doas -u $NONROOTUSER test -r ${file[i]} && doas -u $NONROOTUSER test -w ${file[i]} && {
		echo ${file[i]} can be edited without root priviledges
		clear_and_exit
	}

	# absolute path of the temp_file : filename__hash
	temp_file[i]="$doaseditdir/$(basename ${file[i]})__$(echo "${$}_$i_$RANDOM_$(date)" | md5sum | awk '{ print $1 }')" &&

	# if argument is a valid file then copy it to temp_file with proper permissions otherwise make an empty temp_file
	# the temp_file should be owned by root and can be read and written by NONROOTUSER
	if [[ -f ${file[i]} ]]; then
		install -g $NONROOTUSER -m 660 ${file[i]} ${temp_file[i]}
	elif [[ -d $directory ]]; then
		# if the argument is a directory then exit
		[[ -d ${file[i]} ]] && {
			echo cannot edit a directory
			clear_and_exit
		}
		# if the directory is writable without root priviledges then exit
		doas -u $NONROOTUSER test -w $directory && {
			echo editing files in a writable directory is not permitted
			clear_and_exit
		}
		# create the temp file
			touch ${temp_file[i]}
	# if the file and directory containing the file does not exist then exit
	else
		echo No such dir : $(dirname ${file[i]}); rm ${temp_file[@]}; exit 1
	fi

	# get the initial modification time
	mod_time1[i]="$(stat -c %y ${temp_file[i]})"
done

# open files in EDITOR
doas -u $NONROOTUSER $EDITOR ${temp_file[@]} || { echo Failed to open files in $EDITOR; clear_and_exit }

# copy the contents to the original file
for i in $(seq 1 $#)
do
	# compare the final and initial modification time. if modified then copy the contents
	mod_time2[i]="$(stat -c %y ${temp_file[i]})" &&
	if [[ ${mod_time1[i]} != ${mod_time2[i]} ]]; then
		cat ${temp_file[i]} > ${file[i]} &&
		echo Modified ${file[i]}
	else
		echo ${file[i]} not modified
	fi

	# remove the temporary file created for editing in non root environment
	rm ${temp_file[i]}
done
