#! /usr/bin/sh

# unalias stuff
unalias doas echo ls grep awk date md5sum rm stat cat install chgrp dirname basename exit 2> /dev/null

# check dependencies
command -v doas echo ls grep awk date md5sum rm stat cat install chgrp dirname basename exit > /dev/null || {
	echo dependencies not satisfied; exit 1
}

# check if env vars are set properly
[[ $USER != "root" ]] && {
	echo please run with root priviledges; exit 1
}
[[ $NONROOTUSER == "root" ]] && {
	echo please run doasedit from a non root user; exit 1
}
{ [[ -z $NONROOTUSER ]] || [[ -z $EDITOR ]] ;} && {
	echo please set env vars properly; exit 1
}
# if number of arguments is zero then exit
[[ $# -eq 0 ]] && {
	echo No arguments; exit 1
}
# do not allow process substitution in arguments
[[ $@ =~ ".*/proc/self/fd/.+" ]] && {
	echo please do not use process substitution in arguments; exit 1
}

# directory for storing temporary files
doaseditdir="/tmp/doasedit"
# if the directory exists then check for permissions. otherwise create the directory
# the directory should be owned by root and the group should be NONROOTUSER.
# NONROOTUSER can only execute the directory and others can do nothing
doaseditdit_permission="drwx--x---root$NONROOTUSER"
if [[ -d $doaseditdir ]]; then
	[[ $(ls -l $(dirname $doaseditdir) | grep $(basename $doaseditdir) |
	awk '{ print $1 $3 $4 }') != $doaseditdit_permission ]] && {
		echo improper permissions for $doaseditdir; exit 1
	}
else
	{ mkdir -m 710 $doaseditdir &&
	chgrp $NONROOTUSER $doaseditdir; } ||
	{ echo failed to create directory; exit 1; }
fi

# declaring some arrays
declare -a file temp_file mod_time1 mod_time2
# clear files and exit
clear_and_exit () {
	! [[ -z $(printf %s ${temp_file[@]}) ]] && rm ${temp_file[@]}
	exit 1
}

args=$@
for (( i=0; i < $#; i++ ))
do
	# if absolute path is given use that otherwise expand the location
	if [[ ${args[i]:0:1} == "/" ]]; then
		file[i]="${args[i]}"
	else
		file[i]="$PWD/${args[i]}"
	fi
	directory="$(dirname ${file[i]})"


	# absolute path of the temp_file : filename__hash
	temp_file[i]="$doaseditdir/$(basename ${file[i]})__$(echo "${$}_$i_$RANDOM_$(date)" | md5sum | awk '{ print $1 }')"

	# if argument is a valid file then copy it to temp_file with proper permissions otherwise make an empty temp_file
	# the temp_file should be owned by root and can be read and written by NONROOTUSER
	if [[ -f ${file[i]} ]]; then
		# if the file can be edited without root priviledges then exit
		doas -u $NONROOTUSER test -r ${file[i]} && doas -u $NONROOTUSER test -w ${file[i]} && {
			echo ${file[i]} : editing files in a writable directory is not permitted
			clear_and_exit
		}

		install -g $NONROOTUSER -m 660 ${file[i]} ${temp_file[i]} ||
			{ echo Falied to copy ${file[i]} ; exit 1; }
	elif [[ -d $directory ]]; then
		# if the argument is a directory then exit
		[[ -d ${file[i]} ]] && {
			echo ${file[i]} : cannot edit a directory
			# since temp_file[i] is not created
			unset "temp_file[i]"
			clear_and_exit
		}
		# if the directory is writable without root priviledges then exit
		doas -u $NONROOTUSER test -w $directory && {
			echo ${file[i} : editing files in a writable directory is not permitted
			# since temp_file[i] is not created
			unset "temp_file[i]"
			clear_and_exit
		}
		# create the temp file
		touch ${temp_file[i]} || {
			echo ${file[i]} : Failed to create temp file
			exit 1
		}
	# if both the file and the directory containing the file does not exist then exit
	else
		echo ${file[i]} : No such dir $(dirname ${file[i]})
		# since temp_file[i] is not created
		unset "temp_file[i]"
		clear_and_exit
	fi

	# get the initial modification time
	mod_time1[i]="$(stat -c %y ${temp_file[i]})"
done

# open files in EDITOR
doas -u $NONROOTUSER $EDITOR ${temp_file[@]} || {
	echo Failed to open files in $EDITOR; clear_and_exit
}

# copy the contents to the original file
for (( i=0; i < $#; i++ ))
do
	# compare the final and initial modification time. if modified then copy the contents
	mod_time2[i]="$(stat -c %y ${temp_file[i]})" &&
	if [[ ${mod_time1[i]} != ${mod_time2[i]} ]]; then
		cat ${temp_file[i]} > ${file[i]} || {
			echo failed to modify ${file[i]}
			continue
		} &&
		echo Modified ${file[i]}
	else
		echo ${file[i]} not modified
	fi

	# remove the temporary file created for editing in non root environment
	rm ${temp_file[i]}
done
